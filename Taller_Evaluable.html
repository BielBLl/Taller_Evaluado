<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Taller evaluado de repaso para el Primer Parcial</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Taller_Evaluable_files/libs/clipboard/clipboard.min.js"></script>
<script src="Taller_Evaluable_files/libs/quarto-html/quarto.js"></script>
<script src="Taller_Evaluable_files/libs/quarto-html/popper.min.js"></script>
<script src="Taller_Evaluable_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Taller_Evaluable_files/libs/quarto-html/anchor.min.js"></script>
<link href="Taller_Evaluable_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Taller_Evaluable_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Taller_Evaluable_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Taller_Evaluable_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Taller_Evaluable_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#primer-paso" id="toc-primer-paso" class="nav-link active" data-scroll-target="#primer-paso">Primer paso:</a></li>
  <li><a href="#segundo-paso" id="toc-segundo-paso" class="nav-link" data-scroll-target="#segundo-paso">Segundo paso:</a></li>
  <li><a href="#tercer-paso" id="toc-tercer-paso" class="nav-link" data-scroll-target="#tercer-paso">Tercer paso</a></li>
  <li><a href="#cuarto-paso" id="toc-cuarto-paso" class="nav-link" data-scroll-target="#cuarto-paso">Cuarto paso</a></li>
  <li><a href="#quinto-paso" id="toc-quinto-paso" class="nav-link" data-scroll-target="#quinto-paso">Quinto paso</a></li>
  <li><a href="#sexto-paso" id="toc-sexto-paso" class="nav-link" data-scroll-target="#sexto-paso">Sexto paso</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Taller evaluado de repaso para el Primer Parcial</h1>
<p class="subtitle lead">20582- Análisis de Datos para el GMAT</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Elige un tema que te interese (finanzas, medio ambiente, educación, cine, entre otros). En este taller, aplicarás los pasos del método científico (ver sección 1.1 de los apuntes de la asignatura) para abordar, con datos simulados, una problemática relacionada con el tema elegido. Deberás presentar un informe de tu proyecto siguiendo la estructura detallada en el documento “Recomendaciones para escribir informes de proyectos en Estadística,” que se encuentra en la sección “Práctica” de la página del curso en Aula Digital.</p>
<section id="primer-paso" class="level3">
<h3 class="anchored" data-anchor-id="primer-paso">Primer paso:</h3>
<p>Define los objetivos de tu trabajo: Describe la hipótesis general que deseas investigar y especifica los objetivos específicos necesarios para validar o refutar dicha hipótesis.</p>
<p><a href="https://github.com/BielBLl/Taller_Evaluado">Enlace al GitHub</a></p>
<p>Nos centraremos en el estudio de internación hospitalaria en España, definiremos como variables cuantitativas “altura”, “horas_de_sueño”, “tiempo_hasta_hospitalizacion” y “edad”, donde la altura está en centímetros y el tiempo hasta hospitalización en días, esté último intenta reflejar el efecto de tardar demasiado a acudir a un serivicio de salud.</p>
<p>Para las ordinales escogemos expectativa, cantidad de dolor y calidad de la estancia. De los tres, el más interesante es la expectativa de los individuos de mejorar o no y poder lo comparar posteriormente a la razón de alta.</p>
<p>Para finalizar, escogemos como nominales el sexo y la razón de alta.</p>
<p>Claramente, al ser datos creados, carecerán de sentido estos estudios, pero procedemos imaginando que son valores genuinos.</p>
<p>Algunas de las hipótesis que nos podríamos plantear:</p>
<ul>
<li>Posible relación Edad-Tiempo hasta hospitalización:</li>
</ul>
<p>Para este objetivo necesitamos ver un test de correlación entre las dos variables y ver si esta es o no lo suficiente alta</p>
<ul>
<li>Relación horas de sueño con cantidad de dolor:</li>
</ul>
<p>Similar a lo anterior, con un Heat Map podremos solucionar-lo.</p>
<ul>
<li>Gente con bajas expectativas implica mayor incidencia de defunción y análogo con altas expectativas:</li>
</ul>
<p>Podemos usar contraste de hipótesis simple donde la hipótesis nula sea que la probabilidad de defunción con bajas expectativas sea mayor que por ejemplo la de expectativa estable.</p>
</section>
<section id="segundo-paso" class="level3">
<h3 class="anchored" data-anchor-id="segundo-paso">Segundo paso:</h3>
<p>Define las variables clave para probar tu hipótesis. Asegúrate de incluir al menos cuatro variables cuantitativas, tres ordinales y dos nominales. Indica las unidades de medida para las variables cuantitativas y los niveles para las variables nominales y ordinales. A continuación, simula los datos en R de acuerdo a las siguientes pautas:</p>
<ul>
<li><strong>Tabla 1</strong>: Genera una tabla con al menos 100 observaciones y las variables definidas en el paso anterior, asegurate que las variables cuantitativas sigan una distribución normal multivariante.</li>
</ul>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 150
Columns: 9
$ altura                       &lt;dbl&gt; 170.4, 169.7, 170.9, 170.0, 170.5, 172.8,…
$ horas_sueno                  &lt;dbl&gt; 6, 6, 8, 6, 5, 7, 11, 1, 5, 10, 9, 3, 8, …
$ tiempo_hasta_hospitalizacion &lt;dbl&gt; 16.8, 13.5, 16.8, 20.7, 15.3, 10.4, 12.9,…
$ edad                         &lt;dbl&gt; 39.2, 40.2, 39.3, 41.2, 40.2, 39.9, 39.3,…
$ expectativa                  &lt;ord&gt; Estable, Estable, Mejorar, Empeorar, Esta…
$ cantidad_dolor               &lt;ord&gt; Medio, Bajo, Muy Bajo, Muy Alto, Muy Alto…
$ calidad_estancia             &lt;ord&gt; Muy Mala, Mala, Muy Buena, Muy Mala, Mala…
$ sexo                         &lt;chr&gt; "Mujer", "Hombre", "Hombre", "Mujer", "Ho…
$ razon_alta                   &lt;chr&gt; "Otras Causas", "Fallecimiento", "Mejoria…</code></pre>
</div>
</div>
<ul>
<li><strong>Tabla 2</strong>: Consigue algunos datos en Internet que puedas utilizar para ayudar a resolver tu problema (una variable o dos basta), algunas ideas de dónde buscar son: <a href="https://datos.gob.es/es/">datos abiertos del Gobierno de España</a>, <a href="https://www.ine.es/ss/Satellite?L=0&amp;c=Page&amp;cid=1259942408928&amp;p=1259942408928&amp;pagename=ProductosYServicios%2FPYSLayout">INE</a>, <a href="https://www.kaggle.com/">Kaggle</a>, etc.</li>
</ul>
<p>Une ambas tablas utilizando un identificador simulado en una base de datos única. Emplea las funciones del paquete tidyverse explicadas en la sección 1.7.5 de los apuntes de la asignatura. Esta parte es opcional, pero te permitirá enriquecer tu base de datos y realizar análisis más completos.</p>
<p>Usaremos el siguiente data.frame: <a href="https://datos.gob.es/es/catalogo/ea0010587-estancia-media-segun-el-sexo-el-motivo-del-alta-y-el-diagnostico-principal-identificador-api-tpx-sociedad_2589-salud_2590-emh_8591-a2022_11029-l0-01018-px">Estancia Media</a> para añadir información a los valores generados, imaginemos que la población del estudio sufren turberculosis, denotado por el codigo 0103 en el data.frame del GOB.</p>
<p>Los días que suelen estar hospitalizados hasta darse de alta son 21.57 para ambos sexos, 24.3 para hombres y 15.66 para mujeres. Entonces imaginemos que sigue una distribución normal con un sigma desconocid que nos inventaremos, ya que no hay información de esta en los bancos de datos sobre tuberculosis.</p>
<p>Si la media de días ingresado es de unos 21.57 podemos imaginarnos que no puede tener gran desviación e imponemos <span class="math inline">\(\sigma^2=3\)</span></p>
<p>Entonces esta variable <span class="math inline">\(X\sim N(21.57,3)\)</span>, hacemos una simulación de 150 datos y la añadimos al dataframe inicial:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>Rows: 150
Columns: 10
$ altura                       &lt;dbl&gt; 170.4, 169.7, 170.9, 170.0, 170.5, 172.8,…
$ horas_sueno                  &lt;dbl&gt; 6, 6, 8, 6, 5, 7, 11, 1, 5, 10, 9, 3, 8, …
$ tiempo_hasta_hospitalizacion &lt;dbl&gt; 16.8, 13.5, 16.8, 20.7, 15.3, 10.4, 12.9,…
$ edad                         &lt;dbl&gt; 39.2, 40.2, 39.3, 41.2, 40.2, 39.9, 39.3,…
$ expectativa                  &lt;ord&gt; Estable, Estable, Mejorar, Empeorar, Esta…
$ cantidad_dolor               &lt;ord&gt; Medio, Bajo, Muy Bajo, Muy Alto, Muy Alto…
$ calidad_estancia             &lt;ord&gt; Muy Mala, Mala, Muy Buena, Muy Mala, Mala…
$ sexo                         &lt;chr&gt; "Mujer", "Hombre", "Hombre", "Mujer", "Ho…
$ razon_alta                   &lt;chr&gt; "Otras Causas", "Fallecimiento", "Mejoria…
$ duracion_estancia            &lt;dbl&gt; 23.4, 21.7, 23.9, 25.4, 22.7, 21.1, 22.8,…</code></pre>
</div>
</div>
</section>
<section id="tercer-paso" class="level3">
<h3 class="anchored" data-anchor-id="tercer-paso">Tercer paso</h3>
<p>Realiza un análisis descriptivo multivariantes de tu base de datos de acuerdo a los objetivos de tu trabajo. Describe lo observado en el contexto del problema.</p>
<p>Primero veremos si existe alguna correlación entre Edad-Tiempo_hasta_hospitalización y Horas_de_sueño- Dolor, usaremos la función ggpairs para conseguirlo.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Taller_Evaluable_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Mágicamente, aun siendo datos simulados, podemos ver una leve correlación entre edad y tiempo_hasta_hospitalización. Aunque muchas de nuestras variables muestran cierta correlación menos con el sexo.</p>
<p>Veamos más de cerca el gráfico de puntos que nos aporta ggpairs:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Taller_Evaluable_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Podemos intuir una regresión lineal muy muy de débil gracias al gráfico, ya que a mayor edad, mayor el tiempo hasta hospitalización de medio.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = tiempo_hasta_hospitalizacion ~ edad, data = dt)

Residuals:
    Min      1Q  Median      3Q     Max 
-9.3588 -2.7257 -0.2831  2.6353 12.0379 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept)  -37.967      9.838  -3.859 0.000169 ***
edad           1.261      0.246   5.129 9.01e-07 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 3.953 on 148 degrees of freedom
Multiple R-squared:  0.1509,    Adjusted R-squared:  0.1452 
F-statistic:  26.3 on 1 and 148 DF,  p-value: 9.008e-07</code></pre>
</div>
</div>
<p>El modelo nos dice claramente que hay un gran error mínimo y máximo, por lo que no se ajusta bien a los puntos debido al valor bajísimo de R_squared=0.1452. Por lo tanto, negamos que pueda seguir una modelo de regresión lineal.</p>
<p>Añadimos la recta de regresión al gráfico anterior</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Taller_Evaluable_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Al añadir la recta podemos ver claramente lo mal ajustada que está a los puntos de la gráfica.</p>
<p>Respecto la relación Horas de Sueño-Dolor, podemos veamos mas en detalle el estudio con boxplots que nos ofrece ggpairs.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Taller_Evaluable_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>De nuevo, al ser datos simulados pueden carecer de sentido. Por lo que parece, estadísticamente hablando la media de horas de sueño de media no varía, carece de sentidom ya que a mayor dolor, más duermen en general los pacientes.</p>
<p>Veamos con un contraste si la hipótesis nula <span class="math inline">\(H_0: \mu_i=\mu_j\; \forall i,j\)</span> es o no cierta. Al no saber si los valores de varianza son o no iguales usaremos la función pairwise.wilcox.test para descubrir si tienen mismas medias.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
    Pairwise comparisons using Wilcoxon rank sum test with continuity correction 

data:  sub_data$horas_sueno and sub_data$cantidad_dolor 

         Muy Bajo Bajo Medio Alto
Bajo     1        -    -     -   
Medio    1        1    -     -   
Alto     1        1    1     -   
Muy Alto 1        1    1     1   

P value adjustment method: holm </code></pre>
</div>
</div>
<p>Gracias a la función que hemos comentado podemos afirmar la hipótesis nula con muchísima seguridad, este resultado perfecto parece muy extraño, pero se han comprobado con otros metodos de contraste con resultados iguales, algunos de los intentados son pairwise.t.test, kruskal, etc… Por lo tanto, estadísticamente hablando tienen la misma media.</p>
<p>Pacientes con valores de dolor bajo parecen tener un sueño más consistente, menos algunos valores atípicos. Si los pacientes con valores muy bajos de dolor tuviesen sueño consistente podríamos intuir alguna relación. La media de horas de sueño ronda las 6.8 horas, lo cual es más o menos normal debido a la edad de los sujetos, la cual ronda los 40.</p>
<p>Para las variables cuantitativas de tu base de datos, calcula e interpreta la información que proporciona la varianza generalizada y la varianza total.</p>
<p>Encontremos la matriz de convarianzas de los datos cuantitativos primero:</p>
<p>Ahora que tenemos tanto la matriz como sus valores própios, podemos calcular la varianza generalizada y la varianza total.</p>
<p>Por lo que obtenemos una varianza generalizada de 1952.75 y una varianza total de 41.64.</p>
<p>Al entender la varianza generalizada como la dispersión global del conjunto de variables dadas, podemos ver como tiene un valor altísimo, seguramente debido a que las variables están simuladas aleatoriamente.</p>
<p>En cambio, la varianza total como media general de dispersión está relativamente baja si tenemos en cuenta que algunos valores como la altura fluctúan mucho por construcción.</p>
</section>
<section id="cuarto-paso" class="level3">
<h3 class="anchored" data-anchor-id="cuarto-paso">Cuarto paso</h3>
<p>Selecciona una de las variables no cuantitativas y modelízala con una distribución multinomial, debes estimar sus parámetros. Utiliza el modelo para calcular la probabilidad de que ocurra un evento de interés en una muestra de tamaño 20, relevante para tu problema.</p>
<p>De las variables no cuantitativas las más interesantes son calidad de la estancia i cantidad de dolor, escogeremos la cantidad de dolor, ya que anteriormente la hemos estudiado un poco.</p>
<p>Usaremos el paquete XNomial para ver si sigue</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Muy Bajo     Bajo    Medio     Alto Muy Alto 
      25       32       32       32       29 </code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.1538462 0.2307692 0.2307692 0.2307692 0.1538462</code></pre>
</div>
</div>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
P value (LLR) = 0.7072</code></pre>
</div>
</div>
<p>Por lo tanto, no podemos rechazar la hipótesis nula por lo que la distribución de la variable “cantidad _dolor” sea una multinomial con parámetros (0.15,0.23,0.23,0.23,0.15).</p>
<p>Ahora que sabemos que modelo sigue, veamos qué probabilidad hay de que de 20 encuestados un 80% presente dolor muy alto y 20% alto.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.353293e-12</code></pre>
</div>
</div>
<p>Esto nos dará una probabilidad tan cercana al cero que podemos despreciar-la</p>
</section>
<section id="quinto-paso" class="level3">
<h3 class="anchored" data-anchor-id="quinto-paso">Quinto paso</h3>
<p>Con las variables cuantitativas de tu base de datos, ajusta un modelo de regresión multivariante en la forma:</p>
<p><span class="math display">\[Y=\beta_0+\beta_1 X_1+ \cdots + \beta_p X_p + \epsilon\]</span> Donde <span class="math inline">\(Y\)</span> es la variable cuantitativa que deseas explicar en función del resto de variables cuantitativas registradas. Además, calcula la función de score e interpreta su resultado en el contexto del problema.</p>
<p>Intentaremos explicar la edad de los pacientes por un modelo de regresión multivariante donde <span class="math inline">\(X_1\)</span> y <span class="math inline">\(X_2\)</span> son las horas de sueño y los días hasta hospitalización respectivamente. Escogemos estos debido a que son los que presentan más correlación la variable edad.</p>
<p>Procedemos por método directo calculando los valores <span class="math inline">\(\beta_i\)</span>.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>    [,1]
   38.01
x1  0.09
x2  0.11</code></pre>
</div>
</div>
<p>Por lo tanto, <span class="math inline">\(\beta_0=38.01\)</span>,<span class="math inline">\(\beta_1=0,09\)</span> y <span class="math inline">\(\beta_2=0.11\)</span>. <span class="math display">\[Y=38.01+0.09X_1+0.11X_2 + \epsilon\]</span> Podemos también conseguir-lo usando la función lm de R que además da sus errores:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = y ~ x1 + x2)

Residuals:
    Min      1Q  Median      3Q     Max 
-2.7320 -0.7317 -0.0512  0.6413  3.5449 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) 38.01321    0.37505 101.354  &lt; 2e-16 ***
x1           0.08974    0.04186   2.144   0.0337 *  
x2           0.10790    0.02369   4.555 1.09e-05 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 1.203 on 147 degrees of freedom
Multiple R-squared:  0.1766,    Adjusted R-squared:  0.1654 
F-statistic: 15.77 on 2 and 147 DF,  p-value: 6.251e-07</code></pre>
</div>
</div>
<p>Apartir del valor “Adjusted R_squared” podemos ver como este modelo no se acerca nada bien a los valores de Y, aun así es d’esperar debido a la naturaleza aleatoria de valores simulados con parámetros aleatorios.</p>
<p>Debido a que no nos aporta informació, veamos si podemos explicar alguna otra variable con este método. Probemos explicar los dias hasta hospitalización con la altura y la edad. Escogemos estos debido a la relativamente alta correlación entre ellos.</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
lm(formula = dt$tiempo_hasta_hospitalizacion ~ dt$altura + dt$edad)

Residuals:
    Min      1Q  Median      3Q     Max 
-9.1597 -2.5311 -0.2272  2.4691  9.6346 

Coefficients:
            Estimate Std. Error t value Pr(&gt;|t|)    
(Intercept) -85.3588    15.2614  -5.593 1.06e-07 ***
dt$altura     0.3096     0.0786   3.939 0.000126 ***
dt$edad       1.1299     0.2371   4.766 4.47e-06 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 3.773 on 147 degrees of freedom
Multiple R-squared:  0.232, Adjusted R-squared:  0.2215 
F-statistic:  22.2 on 2 and 147 DF,  p-value: 3.767e-09</code></pre>
</div>
</div>
<p>De nuevo, no nos da un gran ajuste, pero es marginalmente mejor que el anterior.</p>
<p>Encontremos la función score de la distribución <span class="math inline">\(Y=\beta X\)</span>, donde <span class="math inline">\(\beta=(\beta_1,\beta_2)\)</span> y <span class="math inline">\(X=(1,X_1,X_2)\)</span> por lo tanto tenemos que <span class="math inline">\(Y\sim N(X,\beta,\sigma^2I)\)</span> gracias a la teoria.</p>
<p><span class="math display">\[f(Y|\beta,\sigma)=\frac{1}{(2\pi\sigma^2)^{\frac{n}{2}}}\exp(-\frac{1}{2\sigma^2}(Y-X\beta)'(Y-X\beta))\]</span> Aplicamos logaritmo y derivamos respecto <span class="math inline">\(\beta\)</span> y obtenemos: <span class="math display">\[Score(\beta)=\frac{\partial l}{\partial \beta}=\frac{1}{\sigma^2}X^T(Y-X\beta)\]</span> Como podemos interpretar esta función? Dos casos, si la función score vale 0 esto implicará que <span class="math inline">\(Y=X\beta\)</span> y por lo tanto los que minimizan el error <span class="math inline">\(\epsilon\)</span> de del modelo de regresión. Si, en cambio, este valor no da 0 implicará que existe un error <span class="math inline">\(\epsilon &gt;0\)</span>, y por lo tanto podriamos encontrar un ajuste mejor para el modelo de regresión multivariante.</p>
</section>
<section id="sexto-paso" class="level3">
<h3 class="anchored" data-anchor-id="sexto-paso">Sexto paso</h3>
<p>Realiza un contraste de hipótesis de dos medias multivariante que sea relevante para tu problema. Por ejemplo, podrías evaluar si el vector de medias de la variable cuantitativa de interés <span class="math inline">\(Y\)</span> es el mismo para dos niveles distintos de la variable no cuantitativa que modelaste como multinomial en el paso anterior. Ejecuta el contraste tanto teóricamente como con la función hotelling.test en R. Escribe la conclusión del contraste en el contexto de tu problema.</p>
<p>Para este último nos encontraremos con problemas debido a la naturaleza de los datos, hay elementos que rondan numeros altos como la altura y otros que rondas bajos, como las horas de sueño.</p>
<p>Aun así, definimos <span class="math inline">\(X\)</span> y <span class="math inline">\(Y\)</span> como las variables horas de sueño y tiempo hasta hospitalización.</p>
<p><span class="math display">\[X\sim N_p(\mu_1,\Sigma), \:Y\sim N_p(\mu_2,\Sigma)\]</span></p>
<p><span class="math display">\[H_0:\mu_1=\mu_2\]</span> Recordemos que <span class="math inline">\(n_1=n_2=150\)</span> al estudiar 150 sujetos y que <span class="math inline">\(p=1\)</span>, ya que solo nos fijamos en un variable. Primero vemos teoricamente el contraste, al ser <span class="math inline">\(\Sigma\)</span> desconocida debemos usar que:</p>
<p><span class="math display">\[\frac{(150+150-1-1)150*150}{(150+150-2)(150+150)}(\bar{x}-\bar{y})'\widehat{S}^{-1}(\bar{x}-\bar{y})\sim F^1_{298}\]</span></p>
<p><span class="math display">\[33.32256\sim F^1_{298}\]</span></p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>              [,1]
[1,] 2.399437e-144</code></pre>
</div>
</div>
<p>Nos da un valor menor al nivel de significació standard por lo que rechazamos la hipótesis de que sean iguales, lo qual era de esperar ya que no tenemos variables con medias similares</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>